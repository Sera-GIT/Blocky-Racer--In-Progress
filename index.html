<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocky Racer: Motion Delta</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', Arial, sans-serif; }
        
        #debug-panel {
            position: fixed; top: 10px; left: 10px; width: 300px;
            background: rgba(0,0,0,0.8); color: #00ff00; 
            padding: 15px; border-left: 4px solid #00ff00;
            font-family: monospace; z-index: 10000;
            pointer-events: none;
        }
        
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 999; transition: opacity 0.5s; }
        #hud { position: absolute; top: 20px; right: 20px; color: white; text-shadow: 2px 2px 4px #000; z-index: 10; pointer-events: none; text-align: right; }
        #menuBtn { position: absolute; bottom: 20px; right: 20px; background: rgba(0,0,0,0.6); color: white; border: 2px solid white; padding: 10px 20px; font-size: 18px; font-weight: bold; cursor: pointer; z-index: 20; border-radius: 5px; pointer-events: auto; }
        #overlayScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 50; color: white; backdrop-filter: blur(5px); }
        .big-btn { padding: 20px 60px; font-size: 32px; background: #4CAF50; color: white; border: none; border-radius: 10px; cursor: pointer; margin-top: 20px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        .bt-btn { padding: 15px 40px; font-size: 20px; background: #2196F3; color: white; border: none; border-radius: 30px; cursor: pointer; margin-top: 20px; display: flex; align-items: center; gap: 10px; }
        .bt-btn.connected { background: #607D8B; cursor: default; }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    
    <div id="debug-panel">
        <div>STATUS: <span id="st">DISCONNECTED</span></div>
        <div>CURRENT ANGLE: <span id="curr">0.0</span></div>
        <div>ROTATION SPEED: <span id="delta">0.0</span></div>
        <div>ACTION: <span id="action" style="color:yellow">RELEASED</span></div>
    </div>

    <div id="loader"><h1>Loading Game...</h1></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        // GLOBAL DEBUG HELPERS
        window.updateDebug = (status, curr, delta, action) => {
            if(status) document.getElementById('st').innerText = status;
            if(curr !== null) document.getElementById('curr').innerText = curr.toFixed(1);
            if(delta !== null) document.getElementById('delta').innerText = delta.toFixed(1);
            if(action) document.getElementById('action').innerText = action;
        };

        const BlockyCarGame = () => {
            const mountRef = useRef(null);
            const [gameStarted, setGameStarted] = useState(false);
            const [gameOver, setGameOver] = useState(false);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [btConnected, setBtConnected] = useState(false);

            const btRef = useRef({ device: null, server: null, sensorChar: null, vibeChar: null, tilt: 0 });
            
            // NEW: Reference to store the PREVIOUS frame's tilt
            const prevTiltRef = useRef(0);
            const isVibratingRef = useRef(false);
            
            const gameStateRef = useRef({
                isGameOver: false, isPaused: false, score: 0,
                movingTime: 0, totalDistance: 0, gridRows: [], opponents: [], difficulty: 'Progressive'
            });

            const SERVICE_UUID = "19b10000-e8f2-537e-4f6c-d104768a1214";
            const SENSOR_CHAR_UUID = "19b10001-e8f2-537e-4f6c-d104768a1214";
            const VIBE_CHAR_UUID = "19b10002-e8f2-537e-4f6c-d104768a1214";

            useEffect(() => {
                const saved = localStorage.getItem('blockyRacerHighScore');
                if (saved) setHighScore(parseInt(saved));
            }, []);

            const connectBluetooth = async () => {
                try {
                    window.updateDebug("SEARCHING...", null, null, null);
                    const device = await navigator.bluetooth.requestDevice({ filters: [{ services: [SERVICE_UUID] }] });
                    device.addEventListener('gattserverdisconnected', () => setBtConnected(false));
                    const server = await device.gatt.connect();
                    const service = await server.getPrimaryService(SERVICE_UUID);
                    
                    const sensorChar = await service.getCharacteristic(SENSOR_CHAR_UUID);
                    await sensorChar.startNotifications();
                    sensorChar.addEventListener('characteristicvaluechanged', (event) => {
                        const decoder = new TextDecoder('utf-8');
                        let val = parseFloat(decoder.decode(event.target.value));
                        if (!isNaN(val)) {
                            // SCALING: Multiply by 10 so raw 0-9.8 becomes 0-98 (Degrees-ish)
                            // This makes the threshold of "5" meaningful
                            btRef.current.tilt = val * 10; 
                        }
                    });

                    const vibeChar = await service.getCharacteristic(VIBE_CHAR_UUID);
                    btRef.current = { device, server, sensorChar, vibeChar, tilt: 0 };
                    setBtConnected(true);
                    window.updateDebug("CONNECTED", 0, 0, "READY");
                } catch (error) {
                    console.error("BLE Error", error);
                    window.updateDebug("ERROR", null, null, null);
                }
            };

            const sendVibration = async () => {
                if (btRef.current.vibeChar && !isVibratingRef.current) {
                    isVibratingRef.current = true;
                    try {
                        const enc = new TextEncoder('utf-8');
                        const data = enc.encode('1');
                        if (btRef.current.vibeChar.properties.writeWithoutResponse) {
                            await btRef.current.vibeChar.writeValueWithoutResponse(data);
                        } else {
                            await btRef.current.vibeChar.writeValue(data);
                        }
                    } catch(e) {}
                    setTimeout(() => { isVibratingRef.current = false; }, 1000);
                }
            };

            const triggerRestart = () => {
                setGameOver(false); setScore(0);
                const ref = gameStateRef.current;
                ref.isGameOver = false; ref.isPaused = false; ref.score = 0;
                ref.opponents.forEach(o => o.mesh.parent?.remove(o.mesh));
                ref.opponents = [];
            };

            useEffect(() => {
                const handleKeyDown = (e) => { if (gameOver && e.code === 'Space') triggerRestart(); };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [gameOver]);

            // --- THREE.JS SCENE ---
            useEffect(() => {
                if (!mountRef.current) return;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x222222);
                scene.fog = new THREE.Fog(0x222222, 10, 200);
                const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 35);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                mountRef.current.appendChild(renderer.domElement);

                // Lighting & Assets
                const l = document.getElementById('loader'); if(l) { l.style.opacity = 0; setTimeout(()=>l.style.display='none',500); }
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                dirLight.position.set(50, 100, 50); dirLight.castShadow = true; scene.add(dirLight);

                // Helper Functions for Cars/World
                const mkBox=(w,h,d,c,x,y,z)=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshLambertMaterial({color:c}));m.position.set(x,y,z);m.castShadow=true;return m;};
                const createCar=(t,c)=>{
                    const g=new THREE.Group();
                    const body=mkBox(2.4,1,4.2,c,0,1,0); 
                    const top=mkBox(2,0.8,2,0x222222,0,1.8,-0.5);
                    g.add(body,top);
                    if(t==='ambulance'){
                        g.remove(top); 
                        g.add(mkBox(2.4,1.5,4,0xFFFFFF,0,1.5,0)); // Boxy
                        g.rotation.y = Math.PI; // FLIP AMBULANCE
                    }
                    else if(t!=='ambulance') g.rotation.y = Math.PI; // Flip others too
                    return g;
                }

                // Setup World
                const playerCar = createCar('sport', 0xFF0055); 
                playerCar.rotation.y = 0; // Player faces forward
                scene.add(playerCar);
                const road = mkBox(30,1,1000,0x333333,0,-0.6,0); scene.add(road);
                const grass = mkBox(500,1,1000,0x1a472a,0,-1.0,0); scene.add(grass);
                
                // --- MAIN GAME LOOP ---
                let speed = 0;
                let currentRot = 0;
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    if (!gameStateRef.current.gameStarted || gameStateRef.current.isGameOver || gameStateRef.current.isPaused) {
                        if(gameStateRef.current.gameStarted) renderer.render(scene, camera); return;
                    }

                    // --- NEW CONTROL LOGIC (DELTA STEERING) ---
                    
                    const THRESHOLD = 0.5; // You asked for 5, but we check rotation speed here. 
                                         // Since we scaled by 10, 0.5 change is significant.
                                         // If it feels too sensitive, increase this to 1.0 or 2.0
                    
                    const currentTilt = btRef.current.tilt;
                    const prevTilt = prevTiltRef.current;
                    
                    // 1. Calculate Rotation Speed (Delta)
                    // If I was at -8, and now at -3. Delta is +5.
                    const rotationDelta = currentTilt - prevTilt;

                    let steeringAction = 0; // 0 = Release, -1 = Left, 1 = Right
                    let actionText = "RELEASED";

                    // 2. Logic: Speed of Rotation determines key press
                    // Note: Since we use X-Axis, usually Negative is Left, Positive is Right
                    
                    if (rotationDelta > THRESHOLD) {
                        // Rapidly rotating Right (or Tilt increasing)
                        steeringAction = 1; // Simulate 'D'
                        actionText = "TURNING RIGHT >>";
                    } 
                    else if (rotationDelta < -THRESHOLD) {
                        // Rapidly rotating Left (or Tilt decreasing)
                        steeringAction = -1; // Simulate 'A'
                        actionText = "<< TURNING LEFT";
                    } 
                    else {
                        // "Stays at same value" -> Delta is near 0
                        steeringAction = 0; // Simulate Release
                        actionText = "RELEASED (HOLDING)";
                    }

                    // Update Debug
                    window.updateDebug(null, currentTilt, rotationDelta, actionText);
                    
                    // Update Previous for next frame
                    prevTiltRef.current = currentTilt;

                    // 3. Apply Steering
                    const STEER_POWER = 0.4;
                    if (playerCar.position.x > -13 && steeringAction < 0) {
                        playerCar.position.x -= STEER_POWER;
                        currentRot = 0.3; // Lean Visual
                    } 
                    else if (playerCar.position.x < 13 && steeringAction > 0) {
                        playerCar.position.x += STEER_POWER;
                        currentRot = -0.3; // Lean Visual
                    } else {
                        currentRot = 0; // Straighten Visual
                    }

                    // Smooth Visual Tilt
                    playerCar.rotation.y += (currentRot - playerCar.rotation.y) * 0.1;
                    camera.position.x = playerCar.position.x * 0.6;

                    // --- GAME MECHANICS ---
                    if(speed < 0.8) speed += 0.005;
                    gameStateRef.current.score += 1;
                    setScore(Math.floor(gameStateRef.current.score/10));

                    // Spawning
                    if (Math.random() < 0.02) {
                        const lanes = [-10, 0, 10];
                        const type = Math.random()<0.3?'ambulance':'sedan';
                        const col = type==='ambulance'?0xFFFFFF:0x0088ff;
                        const enemy = createCar(type, col);
                        enemy.position.set(lanes[Math.floor(Math.random()*3)], 0, -300);
                        scene.add(enemy);
                        gameStateRef.current.opponents.push(enemy);
                    }

                    // Move Enemies
                    const ops = gameStateRef.current.opponents;
                    for (let i = ops.length - 1; i >= 0; i--) {
                        const enemy = ops[i];
                        enemy.position.z += (0.8 + speed); 
                        
                        // Crash
                        if (Math.abs(enemy.position.z) < 4 && Math.abs(enemy.position.x - playerCar.position.x) < 2.5) {
                            sendVibration();
                            setGameOver(true);
                            gameStateRef.current.isGameOver = true;
                        }
                        // Remove
                        if (enemy.position.z > 50) { scene.remove(enemy); ops.splice(i, 1); }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                // Cleanup
                const handleResize = () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
                window.addEventListener('resize', handleResize);
                return () => { window.removeEventListener('resize', handleResize); if(mountRef.current) mountRef.current.innerHTML = ''; };

            }, []);

            return (
                <div style={{width:'100vw', height:'100vh'}}>
                    <div ref={mountRef} style={{width:'100%', height:'100%'}} />
                    {gameStarted && <div id="hud">
                        <h1>Score: {score}</h1>
                        <h3>High Score: {highScore}</h3>
                    </div>}
                    {!gameStarted && <div id="overlayScreen">
                        <h1 style={{fontSize:'80px', color:'#4CAF50'}}>BLOCKY RACER</h1>
                        <h2>Motion Delta Edition</h2>
                        <button className={`bt-btn ${btConnected?'connected':''}`} onClick={!btConnected?connectBluetooth:null}>{btConnected?'âœ“ READY':'ðŸ“¡ CONNECT'}</button>
                        <button className="big-btn" onClick={()=> {setGameStarted(true); gameStateRef.current.gameStarted=true;}}>START</button>
                    </div>}
                    {gameOver && <div id="overlayScreen">
                        <h1 style={{color:'red'}}>CRASH!</h1>
                        <button className="big-btn" onClick={triggerRestart}>RETRY</button>
                    </div>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<BlockyCarGame />);
    </script>
</body>
</html>
